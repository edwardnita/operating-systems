<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Lab/Compute/Synchronization/content/scheduling">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">Scheduling | Operating Systems</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="http://localhost//operating-systems/Lab/Compute/Synchronization/content/scheduling"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Scheduling | Operating Systems"><meta data-rh="true" name="description" content="Up to now we know that the OS decides which thread (not process) runs on each CPU core at each time."><meta data-rh="true" property="og:description" content="Up to now we know that the OS decides which thread (not process) runs on each CPU core at each time."><link data-rh="true" rel="canonical" href="http://localhost//operating-systems/Lab/Compute/Synchronization/content/scheduling"><link data-rh="true" rel="alternate" href="http://localhost//operating-systems/Lab/Compute/Synchronization/content/scheduling" hreflang="en"><link data-rh="true" rel="alternate" href="http://localhost//operating-systems/Lab/Compute/Synchronization/content/scheduling" hreflang="x-default"><link rel="stylesheet" href="/operating-systems/assets/css/styles.17f22a47.css">
<link rel="preload" href="/operating-systems/assets/js/runtime~main.8b9090e9.js" as="script">
<link rel="preload" href="/operating-systems/assets/js/main.f12eebd2.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="theme.common.skipToMainContent"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/operating-systems/"><div class="navbar__logo"><img src="/operating-systems/img/logo.svg" alt="Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/operating-systems/img/logo.svg" alt="Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">SO</b></a><a class="navbar__item navbar__link" href="/operating-systems/Introduction">Introduction</a><a class="navbar__item navbar__link" href="/operating-systems/Lecture">Lecture</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/operating-systems/Lab">Lab</a><a class="navbar__item navbar__link" href="/operating-systems/Assignments">Assignments</a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><main class="docMainContainer_gTbr docMainContainerEnhanced_Uz_u"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Scheduling</h1><p>Up to now we know that the OS decides which <strong>thread</strong> (not process) runs on each CPU core at each time.
Now we&#x27;ll learn about the component that performs this task specifically: <strong>the scheduler</strong>.</p><p>There are thousands of threads running at any time in a modern OS.
The job of the scheduler is to run and pause threads as well as allocate them to the CPU cores, with the following goals:</p><ul><li><strong>fairness</strong>: we do want all threads to get the same chance to run, i.e. run for about the same amount of time</li><li><strong>throughput</strong>: we want to run as many threads to completion so as to complete as many tasks as we can</li></ul><p>To do this, the scheduler must decide, at given times, to suspend a thread, save its current state and let another one run in its place.
This event is called a <strong>context switch</strong>.
A context switch means changing the state of one thread (the replaced thread) from RUNNING to WAITING and the state of the replacement thread from READY / WAITING to RUNNING.</p><ul><li>Quiz?</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="user-level-vs-kernel-level-threads">User-Level vs Kernel-Level Threads<a class="hash-link" href="#user-level-vs-kernel-level-threads" title="Direct link to heading">​</a></h2><p>There are two types of threads.
The threads you&#x27;ve used so far are <strong>kernel-level threads (KLT)</strong>.
They are created and scheduled in the kernel of the OS.
One of the most important of their features is that they offer true parallelism.
With KLTs, we can truly run a program on all the cores of our CPU at once.
But we must pay a price for this: scheduling them is very complex and context switches are costly (in terms of time), especially when switching threads belonging to different processes.</p><p>By contrast, <strong>user-level threads (ULT)</strong> are managed by the user space.
More of the ULTs created by a program are generally mapped to the same kernel thread.
If a process only creates ULTs, then they will all be mapped to the single, main kernel thread of the process.
So if we cannot run code in parallel with ULTs, then why use them?
Well, programs that create many context switches may suffer from the larger overhead if they use kernel-level threads.
In such cases, user-level threads may be useful as context switches bring less overhead between user-level threads.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="practice-user-level-threads-scheduler">Practice: User-Level Threads Scheduler<a class="hash-link" href="#practice-user-level-threads-scheduler" title="Direct link to heading">​</a></h2><p>Go to <code>support/libult</code>.
It contains a minimalist <strong>user-level threads</strong> scheduler.
Compiling it produces a shared library called <code>libult.so</code>.
You can also consult its <a href="https://www.schaertl.me/posts/a-bare-bones-user-level-thread-library/" target="_blank" rel="noopener noreferrer">documentation</a>.
It explains the API as well as its implementation.
The API exposed by the scheduling library is very simple.
It is only made up of 3 functions:</p><ul><li><code>threads_create()</code> creates a new ULT</li><li><code>threads_exit()</code> moves the current ULT to the COMPLETED state</li><li><code>threads_join()</code> waits for a given thread to end and saves its return value in the <code>result</code> argument</li></ul><p>Look inside <code>support/libult/threads.c</code>.
Here you will find the 3 functions mentioned above.</p><p>The scheduler only uses 3 states: RUNNING, READY, COMPLETED.</p><p><a href="/operating-systems/Lab/Compute/Synchronization/quiz/number-of-running-ults">Quiz</a></p><p>The threads in the READY and COMPLETED states are kept in 2 separate queues.
When the scheduler wants to run a new thread, it retrieves it from the READY queue.
When a thread ends its execution, it is added to the COMPLETED queue, together with its return value.</p><p><a href="/operating-systems/Lab/Compute/Synchronization/quiz/why-use-completed-queue">Quiz</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="thread-control-block">Thread Control Block<a class="hash-link" href="#thread-control-block" title="Direct link to heading">​</a></h2><p>Let&#x27;s dissect the <code>threads_create()</code> function a bit.
It first initialises its queues and the timer for preemption.
We&#x27;ll discuss preemption <a href="#scheduling---how-is-it-done">in the next section</a>.
After performing initialisations, the function creates a <code>TCB</code> object.
TCB stands for <strong>Thread Control Block</strong>.</p><p>During the <a href="/operating-systems/Lab/Compute/lecture/">lecture</a>, you saw that the kernel stores one instance of a <a href="https://elixir.bootlin.com/linux/v5.19.11/source/include/linux/sched.h#L726" target="_blank" rel="noopener noreferrer"><code>task_struct</code></a> for each thread.
Remember that its most important fields are:</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct task_struct {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned int                    __state;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void                           *stack;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned int                    flags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int                             on_cpu;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int                             prio;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Scheduler information */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct sched_entity             se;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const struct sched_class        *sched_class;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* The VAS: memory mappings */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct mm_struct                *mm;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int                             exit_state;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int                             exit_code;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pid_t                           pid;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct task_struct __rcu        *parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Child processes */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct list_head                children;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Open file information */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct files_struct             *files;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>As you can see, this <code>struct</code> stores <em>metadata</em> regarding a given thread.
The same is true about the <code>TCB</code> in <code>libult.so</code>:</p><div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">typedef</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> id</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token class-name">ucontext_t</span><span class="token plain"> context</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bool has_dynamic_stack</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token punctuation" style="color:#393A34">(</span><span class="token operator" style="color:#393A34">*</span><span class="token plain">start_routine</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">argument</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">return_value</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"> TCB</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>It stores the thread ID (tid - <code>id</code>), similar to the PID of a process.
It stores a pointer to the function passed as argument to <code>threads_create()</code> (<code>start_routine</code>), as well as the argument (<code>argument</code>) and the returned value (<code>return_value</code>) of said function.</p><p>In addition, the <code>TCB</code> stores a <code>context</code>.
From the <a href="https://pubs.opengroup.org/onlinepubs/7908799/xsh/ucontext.h.html" target="_blank" rel="noopener noreferrer">man page of the <code>ucontext.h</code> header</a>, we can see this type is a <code>struct</code> that stores a pointer to the stack of the current thread (<code>uc_stack</code>).
This is similar to the <code>stack</code> pointer in the <code>task_struct</code> above.
In short, we can say a context defines an execution unit, such as a thread.
<strong>This is why changing the running thread is called a context switch.</strong></p><p>Let&#x27;s compare this context with another thread implementation, from <a href="https://unikraft.org/" target="_blank" rel="noopener noreferrer">Unikraft</a>.
We&#x27;ll look at the <a href="https://github.com/unikraft/unikraft/blob/9bf6e63314a401204c02597834fb02f63a29aaf4/lib/uksched/include/uk/thread.h#L55-L76" target="_blank" rel="noopener noreferrer"><code>uk_thread</code></a> <code>struct</code>, which is the TCB used in Unikraft:</p><div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">uk_thread</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">char</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">name</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">stack</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">tls</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">ctx</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token function" style="color:#d73a49">UK_TAILQ_ENTRY</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">uk_thread</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> thread_list</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token class-name">uint32_t</span><span class="token plain"> flags</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    __snsec wakeup_time</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bool detached</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">uk_waitq</span><span class="token plain"> waiting_threads</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">uk_sched</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">sched</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token operator" style="color:#393A34">*</span><span class="token plain">entry</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">arg</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">prv</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>There are some visible similarities between the two TCBs.</p><p><a href="/operating-systems/Lab/Compute/Synchronization/quiz/tcb-libult-unikraft">Quiz</a></p><p>Therefore, the workflow for creating and running a thread goes like this:</p><div class="language-console codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-console codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">main thread</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    `--&gt; threads_create()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        |--&gt; tcb_new()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            `--&gt; makecontext()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            `--&gt; handle_thread_start() - called using the context</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                |--&gt; start_routine() - the thread runs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            `--&gt; threads_exit()</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Compile and run the code in <code>support/libult/test_ult.c</code>.
If you encounter the following error when running <code>test_ult</code>, remember what you learned about the loader and using custom shared libraries in the <a href="/operating-systems/Lab/software-stack/lab">Software Stack lab</a>.</p><div class="language-console codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-console codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">./test_ult: error while loading shared libraries: libult.so: cannot open shared object file: No such file or directory</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p>Hint: Use the <code>LD_LIBRARY_PATH</code> variable.</p></blockquote><p>Notice that the threads run their code and alternatively, because their prints appear interleaved.
<a href="#scheduling---how-is-it-done">In the next section</a>, we&#x27;ll see how this is done.</p><p><a href="/operating-systems/Lab/Compute/Synchronization/quiz/ult-thread-ids">Quiz</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="scheduling---how-is-it-done">Scheduling - How is it done?<a class="hash-link" href="#scheduling---how-is-it-done" title="Direct link to heading">​</a></h2><p>There are two types of schedulers: <strong>preemptive</strong> and <strong>cooperative</strong>.
When discussing this distinction, we need to first define the notion of <strong>yielding</strong>.
Yielding the CPU means that a thread suspends its own execution and enters the WAITING or READY state, either as a result of a blocking call (I/O operations or calling the scheduler&#x27;s <code>yield()</code> function directly).
So, yielding the CPU triggers a context switch whereby the current thread stops running and another one resumes or starts running in its place.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="cooperative-scheduling">Cooperative Scheduling<a class="hash-link" href="#cooperative-scheduling" title="Direct link to heading">​</a></h3><p>Cooperative scheduling relies on the fact that threads themselves would yield the CPU at some point.
If threads don&#x27;t abide by this convention, they end up monopolising the CPU (since there is no one to suspend them) and end up starving the others.
You can get a feel of this behaviour by running the cooperative <a href="https://github.com/unikraft/unikraft/blob/staging/lib/ukschedcoop/schedcoop.c" target="_blank" rel="noopener noreferrer">scheduler from Unikraft</a> in the <a href="/operating-systems/Lab/Compute/lecture/demo/cooperative-scheduling">lecture demos</a>.</p><p>This type of schedulers have the advantage of being lightweight, thus resulting in less overhead caused by context switches.
However, as we&#x27;ve already stated, they rely on the &quot;good will&quot; of threads to yield the CPU at some point.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="preemptive-scheduling">Preemptive Scheduling<a class="hash-link" href="#preemptive-scheduling" title="Direct link to heading">​</a></h3><p>Preemptive scheduling solves the issue stated above by leaving the task of suspending the currently RUNNING thread and replacing it with another one from the READY queue up to the scheduler.
This increases its complexity and the duration of context switches, but threads now are not required to worry about yielding themselves and can focus on running their code and performing the task for which they are created.</p><p>Preemptive schedulers allow threads to run only for a maximum amount of time, called <strong>time slice</strong> (usually a few milliseconds).
They use timers which fire when a new time slice passes.
The firing of one such timer causes a context switch whereby the currently RUNNING thread is <em>preempted</em> (i.e. suspended) and replaced with another one.</p><p><a href="/operating-systems/Lab/Compute/Synchronization/quiz/type-of-scheduler-in-libult">Quiz</a></p><p>Look at the <code>init_profiling_timer()</code> function.
It creates a timer that generates a <code>SIGPROF</code> signal and then defines a handler (the <code>handle_sigprof()</code> function) that is executed whenever the <code>SIGPROF</code> signal is received.</p><p><a href="/operating-systems/Lab/Compute/Synchronization/quiz/time-slice-value">Quiz</a></p><p>It is this handler that performs the context switch per se.
Look at its code.
It first saves the context of the currernt thread:</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ucontext_t *stored = &amp;running-&gt;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ucontext_t *updated = (ucontext_t *) context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">stored-&gt;uc_flags = updated-&gt;uc_flags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">stored-&gt;uc_link = updated-&gt;uc_link;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">stored-&gt;uc_mcontext = updated-&gt;uc_mcontext;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">stored-&gt;uc_sigmask = updated-&gt;uc_sigmask;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Then it places current thred in the <code>ready</code> queue and replaces it with the first thread in the same queue.
This algorithm (that schedules the first thread in the READY queue) is called <em>Round-Robin</em>:</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">if (queue_enqueue(ready, running) != 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    abort();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if ((running = queue_dequeue(ready)) == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    abort();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The new <code>running</code> thread is resumed upon setting the current context to it:</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">if (setcontext(&amp;running-&gt;context) == -1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    abort();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This is how scheduling is done!</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="practice-another-time-slice">Practice: Another Time Slice<a class="hash-link" href="#practice-another-time-slice" title="Direct link to heading">​</a></h3><ol><li><p>Modify the time slice set to the timer to 2 seconds.
Re-run the code in <code>support/libult/test_ult.c</code>.
Notice that now no context switch happens between the 2 created threads because they end before the timer can fire.</p></li><li><p>Now change the <code>printer_thread()</code> function in <code>test_ult.c</code> to make it run for more than 2 seconds.
See that now the prints from the two threads appear intermingled.
Add prints to the <code>handle_sigprof()</code> function in <code>support/libult/threads.c</code> to see the context switch happen.</p></li></ol></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#user-level-vs-kernel-level-threads" class="table-of-contents__link toc-highlight">User-Level vs Kernel-Level Threads</a></li><li><a href="#practice-user-level-threads-scheduler" class="table-of-contents__link toc-highlight">Practice: User-Level Threads Scheduler</a></li><li><a href="#thread-control-block" class="table-of-contents__link toc-highlight">Thread Control Block</a></li><li><a href="#scheduling---how-is-it-done" class="table-of-contents__link toc-highlight">Scheduling - How is it done?</a><ul><li><a href="#cooperative-scheduling" class="table-of-contents__link toc-highlight">Cooperative Scheduling</a></li><li><a href="#preemptive-scheduling" class="table-of-contents__link toc-highlight">Preemptive Scheduling</a></li><li><a href="#practice-another-time-slice" class="table-of-contents__link toc-highlight">Practice: Another Time Slice</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://curs.upb.ro" target="_blank" rel="noopener noreferrer" class="footer__link-item">Main site<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://ocw.cs.pub.ro/courses/so" target="_blank" rel="noopener noreferrer" class="footer__link-item">OCW<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://www.facebook.com/sisteme.de.operare/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Facebook<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 SO Team</div></div></div></footer></div>
<script src="/operating-systems/assets/js/runtime~main.8b9090e9.js"></script>
<script src="/operating-systems/assets/js/main.f12eebd2.js"></script>
</body>
</html>